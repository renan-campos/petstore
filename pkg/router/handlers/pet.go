/*
 * Swagger Petstore - OpenAPI 3.0
 *
 * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [https://swagger.io](https://swagger.io). In the third iteration of the pet store, we've switched to the design first approach! You can now help us improve the API whether it's by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  _If you're looking for the Swagger 2.0/OAS 2.0 version of Petstore, then click [here](https://editor.swagger.io/?url=https://petstore.swagger.io/v2/swagger.yaml). Alternatively, you can load via the `Edit > Load Petstore OAS 2.0` menu option!_  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)
 *
 * API version: 1.0.11
 * Contact: apiteam@swagger.io
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package handlers

import (
	"crypto/sha256"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"

	"github.com/gorilla/mux"
	"github.com/renan-campos/petstore/pkg/router/handlers/models"
)

// Service Code Start
// For this exercise, I'm ignoring data persistence.
type petID int64

var localID petID

func GeneratePetID() petID {
	out := localID
	localID += 1
	return out
}

func strToPetID(strID string) (petID, error) {
	intID, err := strconv.Atoi(strID)
	if err != nil {
		return 0, err
	}
	return petID(intID), nil
}

var PetNotFound = errors.New("pet not found")
var pets map[petID]models.ValidatedPet = make(map[petID]models.ValidatedPet)

// Service Code End

func AddPet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	rawPet, err := io.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("error reading json: %v\n", err)
		return
	}

	var pet models.Pet
	if err := json.Unmarshal(rawPet, &pet); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("error unmarshalling json: %v\n", err)
		return
	}

	if err := pet.ValidationCondition(
		func(validPet models.ValidatedPet) error {
			serviceCode := func() error {
				id := GeneratePetID()
				validPet.Id = int64(id)
				pets[id] = validPet
				return nil
			}
			if err := serviceCode(); err != nil {
				return fmt.Errorf("error occurred in service: %v", err)
			}
			outPet, err := json.Marshal(validPet)
			if err != nil {
				return fmt.Errorf("error marshalling pet: %v", err)
			}
			if _, err := w.Write(outPet); err != nil {
				return fmt.Errorf("error writing response body: %v", err)
			}
			return nil
		},
		func(invalidPet models.ValidatedPet) error {
			w.WriteHeader(http.StatusBadRequest)
			violations, err := json.Marshal(invalidPet.Violations)
			if err != nil {
				return fmt.Errorf("error marshalling pet violations: %v", err)
			}
			if _, err := w.Write(violations); err != nil {
				return fmt.Errorf("error writing response body: %v", err)
			}
			return nil
		},
	); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("error occurred in AddPet: %v\n", err)
		return
	}
}

func GetPetById(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	urlVars := mux.Vars(r)
	id, ok := urlVars["petId"]
	if !ok {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("Could not find id in url path\n")
		return
	}

	// Service Code Start
	serviceGetById := func(id string) (models.ValidatedPet, error) {
		var pet models.ValidatedPet
		petID, err := strToPetID(id)
		if err != nil {
			return pet, fmt.Errorf("failed to convert pet id: %v", err)
		}
		pet, ok := pets[petID]
		if !ok {
			return pet, PetNotFound
		}
		return pet, nil
	}
	// Service Code End
	pet, err := serviceGetById(id)

	if err != nil {
		switch {
		case errors.Is(err, PetNotFound):
			w.WriteHeader(http.StatusNotFound)
		default:
			w.WriteHeader(http.StatusInternalServerError)
		}
		return
	}

	outPet, err := json.Marshal(pet)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to marshal pet: %v\n", err)
		return
	}
	if _, err := w.Write(outPet); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to write pet: %v\n", err)
		return
	}
	return
}

func DeletePet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	urlVars := mux.Vars(r)
	id, ok := urlVars["petId"]
	if !ok {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("could not get petId parameter from call\n")
		return
	}

	// Service Code Start
	serviceDeleteById := func(id string) error {
		petID, err := strToPetID(id)
		if err != nil {
			return fmt.Errorf("failed to convert id: %v")
		}
		if _, ok := pets[petID]; !ok {
			return PetNotFound
		}
		delete(pets, petID)
		return nil
	}

	err := serviceDeleteById(id)
	if err != nil {
		switch {
		case errors.Is(err, PetNotFound):
			w.WriteHeader(http.StatusNotFound)
		default:
			w.WriteHeader(http.StatusInternalServerError)
			log.Printf("failed to delete pet: %v\n", err)
		}
		return
	}
	w.WriteHeader(http.StatusNoContent)
	return
}

func FindPetsByStatus(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	extractSatusFromRequest := func(r *http.Request) []string {
		return strings.Split(r.URL.Query().Get("status"), ",")
	}
	statusList := extractSatusFromRequest(r)
	if len(statusList) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		log.Printf("Could not find status in url path\n")
		return
	}

	serviceFindPetsByStatus := func(statusList []string) []models.ValidatedPet {
		var matchedPets []models.ValidatedPet
		for _, pet := range pets {
			for _, status := range statusList {
				if pet.Status == models.PetStatus(status) {
					matchedPets = append(matchedPets, pet)
					break
				}
			}
		}
		return matchedPets
	}
	matchedPets := serviceFindPetsByStatus(statusList)

	if len(matchedPets) == 0 {
		w.WriteHeader(http.StatusNoContent)
		return
	}

	outPets, err := json.Marshal(matchedPets)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to marshal pets: %v\n", err)
		return
	}
	if _, err := w.Write(outPets); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to write pets: %v\n", err)
		return
	}
	return
}

func FindPetsByTags(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	extractTagsFromRequest := func(r *http.Request) []string {
		return strings.Split(r.URL.Query().Get("tags"), ",")
	}
	tags := extractTagsFromRequest(r)
	if len(tags) == 0 {
		w.WriteHeader(http.StatusBadRequest)
		log.Printf("Could not find tags in url path\n")
	}

	serviceFindPetsByTags := func(tags []string) []models.ValidatedPet {
		// A recursive approach
		// Start with all the pets, then whittle it down by filtering by tags.
		getAllPets := func() []models.ValidatedPet {
			var allPets = make([]models.ValidatedPet, len(pets))
			var petIdx int
			for petKey := range pets {
				allPets[petIdx] = pets[petKey]
				petIdx++
			}
			return allPets
		}
		filterByTag := func(pets []models.ValidatedPet, tag string) []models.ValidatedPet {
			var matchedPets []models.ValidatedPet
			for _, pet := range pets {
				for _, petTag := range pet.Tags {
					if petTag.Name == tag {
						matchedPets = append(matchedPets, pet)
					}
				}
			}
			return matchedPets
		}
		matchedPets := getAllPets()
		for _, tag := range tags {
			matchedPets = filterByTag(matchedPets, tag)
		}
		return matchedPets
		// An iterative approach
		//var matchedPets []models.ValidatedPet
		//for _, pet := range pets {
		//	var matchedPet bool = true
		//	var petTags = make(map[string]struct{})
		//	for _, petTag := range pet.Tags {
		//		petTags[petTag.Name] = struct{}{}
		//	}
		//	for _, tag := range tags {
		//		if _, ok := petTags[tag]; !ok {
		//			matchedPet = false
		//			break
		//		}
		//	}
		//	if matchedPet {
		//		matchedPets = append(matchedPets, pet)
		//	}
		//}
		//return matchedPets
	}
	matchedPets := serviceFindPetsByTags(tags)

	if len(matchedPets) == 0 {
		w.WriteHeader(http.StatusNoContent)
		return
	}

	outPets, err := json.Marshal(matchedPets)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to marshal pets: %v\n", err)
		return
	}
	if _, err := w.Write(outPets); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to write pets: %v\n", err)
		return
	}
	return
}

func UpdatePetWithForm(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	urlVars := mux.Vars(r)
	petID, ok := urlVars["petId"]
	if !ok {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("Could not find id in url path\n")
		return
	}

	qValues := r.URL.Query()

	// Service Code
	updateFromValues := func(id string, qValues url.Values) error {

		petID, err := strToPetID(id)
		if err != nil {
			return fmt.Errorf("failed to convert pet id: %v", err)
		}
		originalPet, has := pets[petID]
		if !has {
			return fmt.Errorf("Pet with ID %q not found", petID)
		}

		var updatedPet models.Pet
		updatedPet = originalPet.Pet
		if qValues.Has("name") {
			updatedPet.Name = qValues.Get("name")
		}
		if qValues.Has("status") {
			updatedPet.Status = models.PetStatus(qValues.Get("status"))
		}
		return updatedPet.ValidationCondition(
			func(validPet models.ValidatedPet) error {
				savePet := func() error {
					pets[petID] = validPet
					return nil
				}
				if err := savePet(); err != nil {
					return fmt.Errorf("failed to save updated pet: %v", err)
				}
				outPet, err := json.Marshal(validPet)
				if err != nil {
					return fmt.Errorf("error marshalling pet: %v", err)
				}
				if _, err := w.Write(outPet); err != nil {
					return fmt.Errorf("error writing response body: %v", err)
				}
				return nil
			},
			func(invalidPet models.ValidatedPet) error {
				w.WriteHeader(http.StatusBadRequest)
				violations, err := json.Marshal(invalidPet.Violations)
				if err != nil {
					return fmt.Errorf("error marshalling pet violations: %v", err)
				}
				if _, err := w.Write(violations); err != nil {
					return fmt.Errorf("error writing response body: %v", err)
				}
				return nil
			})
	}
	if err := updateFromValues(petID, qValues); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("error occurred while updating pet: %v\n", err)
		return
	}
}

func UpdatePet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusNotImplemented)
}

func UploadFile(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	if err := writeFile("/tmp/photo.png", r.Body); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("error writing photo file: %v\n", err)
		return
	}

	checksum, err := generateChecksum("/tmp/photo.png")
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to generate checksum: %v\n", err)
		return
	}

	if _, err := fmt.Fprintf(w, "%x", checksum); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		log.Printf("failed to write response: %v\n", err)
		return
	}
}

func writeFile(name string, data io.Reader) error {
	f, err := os.Create(name)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = io.Copy(f, data)
	return err
}

func generateChecksum(fileName string) ([]byte, error) {
	var out []byte
	f, err := os.Open(fileName)
	if err != nil {
		return out, err
	}
	defer f.Close()

	h := sha256.New()
	if _, err := io.Copy(h, f); err != nil {
		return out, err
	}
	return h.Sum(nil), nil
}
